# -*- org-pretty-entities-include-sub-superscripts: nil; -*-
				 Notes

* Variables in our instruction
** Op, Vj, Vk, Dest, Imm
* RS variables (defined on *Page 97* of 4th edition)
** Op, Qj, Qk, Vj, Vk, Addr, Busy
* Example of RS, ROB, and RegFile given on *Page 110* of 4th edition
* ROB variables (ROB is 1-indexed)
** Busy, Instr, State, Dest, Value
* RegFile variables
** ROB_index, Busy, Value
* Steps involved in instruction execution given on *Page 106* and *Page 113* of 4th edition
* Branch Speculation:
** In issue stage
*** Set the speculative bit of entries after a branch instruction is inserted in the ROB
**** we will keep a *speculation* variable *which will be set* once a branch is inserted into ROB
**** all the entries (at all points of time) will have their speculative bit = speculation variable
** In commit stage, when a branch reaches the head of ROB
*** flush all ROB entries if this branch is mispredicted (by checking the calculated address and the instruction of next instrution in ROB?)
**** *reset* the speculation varibale
**** also, restart issuing instructions from the *correct address* (depending on branch taken or not taken)
*** finish the branch if it is correctly predicted => reset the speculative bit in the successive instructions (until the next branch instruction?)
**** *reset* the speculation variable


#Devesh: Are we taking care of writing result for store operations only when we reach the head? This is because of branch speculation.
* Program Notes
** ExeModule.py
*** _setRSEntryForImm
**** 
* Refactoring Notes
** ExeModule.py
   CLOCK: [2012-12-06 Thu 14:36]

